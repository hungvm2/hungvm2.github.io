<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title> Đọc và phân tích Paper &#34;You Only Look One: Unified, Real-Time Object Detection&#34;(YOLOv1) - HungVM2&#39;s Notes </title>
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="referrer" content="no-referrer">
    <meta name="description" content="" />
    <meta property="og:site_name" content="HungVM2&#39;s Notes" />
    <meta property="og:locale" content="en_US" />
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://hungvm2.github.io/post/grasping-yolov1-content/" />
    <meta property="og:title" content="Đọc và phân tích Paper &#34;You Only Look One: Unified, Real-Time Object Detection&#34;(YOLOv1)" />
    <meta property="og:image" content="https://hungvm2.github.io" />
    <meta property="og:description" content="" />

    <meta name="twitter:card" content="summary_large_image" />
    
    <meta name="twitter:title" content="Đọc và phân tích Paper &#34;You Only Look One: Unified, Real-Time Object Detection&#34;(YOLOv1)" />
    <meta name="twitter:description" content="" />
    <meta name="twitter:image" content="https://hungvm2.github.io" />

    <link rel="canonical" href="https://hungvm2.github.io/post/grasping-yolov1-content/">

    <link rel="stylesheet" href="https://hungvm2.github.io/css/bootstrap.min.css" />

    
    <link rel="stylesheet" href="https://hungvm2.github.io/css/github-gist.min.css" />
    
    <link rel="stylesheet" href="https://hungvm2.github.io/css/custom.css" />

    

    <link rel="shortcut icon"
        href="https://hungvm2.github.io/images/favicon.png">

    
    <link href="https://hungvm2.github.io/index.xml" rel="alternate" type="application/rss+xml" title="HungVM2&#39;s Notes" />
    

  <script>
  MathJax = {
    tex: {
      tags: 'all',
    inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
  </script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>

<body>
    
    <div class="mt-xl header">
    <div class="container">
        <div class="row justify-content-center">
            <div class="col-auto">
                <a href="https://hungvm2.github.io">
                    <h1 class="name">HungVM2&#39;s notes</h1>
                </a>
            </div>
        </div>

        <div class="row justify-content-center">
            <ul class="nav nav-primary">
                
                <li class="nav-item">
                    <a class="nav-link" href="https://hungvm2.github.io/">
                        
                        Articles
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="https://hungvm2.github.io/the-first-post">
                        
                        About
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="https://hungvm2.github.io/resume.pdf">
                        
                        Resume
                    </a>
                </li>
                
                <li class="nav-item">
                    <a class="nav-link" href="https://hungvm2.github.io/contact">
                        
                        Contact
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</div>

    <div class="content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <h1 class="mx-0 mx-md-4">Đọc và phân tích Paper &#34;You Only Look One: Unified, Real-Time Object Detection&#34;(YOLOv1)</h1>
                    <div class="markdown">
                        
    <p>Trong bài viết này, chúng ta hãy cùng đọc và phân tích nội dung của paper <a href="https://paperswithcode.com/paper/you-only-look-once-unified-real-time-object">&ldquo;You Only Look One: Unified, Real-Time Object Detection&rdquo;</a> pulished năm 2016 nhé!</p>
<blockquote>
<p>Bài viết sẽ chỉ tập trung vào phân tích những ý tưởng chính của YOLO, có bỏ qua một số phần không quá quan trọng</p>
</blockquote>
<h3 id="i-đọc-paper">I. Đọc Paper</h3>
<h4 id="phần-abstract">Phần Abstract</h4>
<p>Các nghiên cứu trước đây xử lý bài toán Object Detection theo hướng Classification (phân loại), còn tác giả YOLO lại tiếp cận theo hướng Regression (hồi quy).</p>
<p>YOLO là một Neural Network đơn nhất dự đoán đồng thời cả Bounding boxes và Class probabilities từ ảnh đầu vào qua một evaluation duy nhất.</p>
<p>Kiến trúc hợp nhất này giúp cho YOLO có thể xử lý ảnh ở tốc độ real-time 45fps. So sánh với các mô hình detect khác, YOLO sai nhiều hơn ở các lỗi về localization errors (sai vị trí của vật thể) nhưng lại ít sai hơn các lỗi false positive (nhận diện nhầm background là vật thể).</p>
<p>YOLO học được các đặc tính của objects một cách tổng quát hơn hẳn các phương pháp khác (như là DPM, R-CNN).</p>
<h4 id="phần-1-introduction">Phần 1: Introduction</h4>
<p>Các phương pháp trước đây detect object bằng cách phân loại object ở các vị trí và kích thước khác nhau trên ảnh đầu vào:</p>
<ul>
<li>Deformable Parts Models (DPM) sử dụng &ldquo;Sliding Window&rdquo; để Classify từng &ldquo;window&rdquo; trên toàn khung hình.</li>
<li>R-CNN sử dụng &ldquo;Region Proposal&rdquo; để đề xuất ra các Bounding boxes tiềm năng trong bức ảnh sau đó phân loại (Classify) trên những boxes này. Phân loại xong, một bước hậu xử lý được sử dụng để định vị lại chính xác các Bounding boxes, bỏ đi các boxes bị trùng lặp&hellip; Hướng tiếp cận này là một Pipeline phức tạp (gồm nhiều step/model nối tiếp nhau) nên rất chậm và khó để tối ưu.</li>
</ul>
<p>Thay vào đó, YOLO là một mạng đơn nhất chỉ cần nhìn ảnh đầu vào một lần duy nhất (You Only Look Once) để dự đoán đồng thời cả Bounding boxes và Class probabilities. Mạng YOLO này có các lợi ích sau:</p>
<ul>
<li>Cực kỳ nhanh, base model đạt tốc độ 45fps trên Titan X GPU nên có thể xử lý luồng video real-time</li>
<li>Dự đoán vật thể dựa trên ngữ cảnh toàn cục (global context) của bức ảnh, điều này giúp giảm các lỗi nhận diện nhầm backgound là vật thể (false positive)</li>
<li>Khả năng tổng quát hoá cao hơn. Khi train trên dữ liệu tự nhiên và test trên dữ liệu artwork, YOLO đạt độ chính xác cao hơn các phương pháp khác như DPM, R-CNN</li>
</ul>
<p>Tuy nhiên YOLO vẫn có nhược điểm: Độ chính xác thấp hơn các phương pháp state-of-the-art khác, khó khăn khi xác định chính xác vị trí của các vật thể, đặc biệt các vật thể cỡ nhõ.</p>
<h4 id="phần-2-unified-detection-mô-hình-phát-hiện-hợp-nhất">Phần 2: Unified Detection (Mô hình Phát hiện hợp nhất)</h4>
<p>Hệ thống YOLO chia ảnh đầu vào thành một lưới SxS các ô vuông (grid cell). Nếu trung tâm (center) của vật thể rơi vào ô vuông nào, thì ô vuông đó sẽ chịu trách nhiệm phát hiện vật thể đó. Tác giả lấy S = 7</p>
<p>Mỗi grid cell cần dự đoán: B bounding boxes, confidence scores của B bounding boxes và C scores của các lớp object (các class/label trong dataset), trong đó:</p>
<ul>
<li>B: Số lượng Bounding boxes cần dự đoán trên 1 cell. Tác giả chọn B = 2</li>
<li>Mỗi bounding box gồm 4 gía trị toạ độ (coordinates): x, y, w, h. Trong đó (x,y) là toạ độ tâm của box được dự đoán, (w,h) là chiều dài và rộng của box</li>
<li>Confidence score (CS): mỗi bounding box có 1 confidence score tương ứng, vậy là sẽ có B confidence scores, tính theo công thức</li>
</ul>
<div class="text-center"><img src="https://hungvm2.github.io/images/yolov1/C_formular.png" alt="Confidence Score"></div>
    Nếu grid cell không có object nào Pr(Object) = 0. Nếu grid cell có object thì Pr(Object) = 1 => CS = IOU của ground truth box và predicted box.
+ C: giá trị xác suất nhân diện của C lớp đối tượng trong model. . Tác giả lấy C = 20 (số lớp đối tượng trong tập dữ liệu PASCAL VOC)
<div class="text-center my-3">C<sub>i</sub> = Pr(Class<sub>i</sub>)|Object)</div>
<p>=&gt; Kích thước (shape) của final output sẽ là:</p>
<div class="text-center my-3">(S , S , B * 4 + B + C) = (7 , 7 , 2 * 4 + 2 + 20) = (7 , 7 , 30)</div>
<h5 id="phần-21-network-design">Phần 2.1. Network Design</h5>
<p>Kiến trúc mạng được truyền cảm hứng bởi mạng GoogLeNet (Inception) (Sử dụng 1x1 Conv layer)</p>
<p>Mạng gồm 24 Convolutional Layers để trích xuất đặc trưng (extract features) và 2 Fully Connected Layers để dự đoán final output. Kiến trúc như bên dưới</p>
<div class="text-center my-3">
<figure class="figure">
  <img src="https://hungvm2.github.io/images/yolov1/network_architecture.png" alt="Network Architecture" class="figure-img">
  <figcaption class="figure-caption">Ảnh 1: Kiến trúc mạng detection của YOLO</figcaption>
</figure>
</div>
Cuối mỗi Conv layer có 1 hàm kích hoạt Leaky ReLU (activation function). Hàm kích hoạt cuối cùng của mạng là hàm linear, predict ra trực tiếp output, không sử dụng non-linear activation function
<h5 id="phần-22-training">Phần 2.2. Training</h5>
<ol>
<li>Bước 1: đặt 20 lớp Conv Layers đầu tiên của mạng detection (Ảnh 1) trong 1 kiến trúc mạng Classification (Input 224x224 =&gt; 24 Conv layers =&gt; 1 Average Pooling layer =&gt; 1 Fully Connected Layer), train trên tập ImageNet 1000 classes. Bước này giúp 24 lớp Conv Layers có bộ weights tốt trong việc trích xuất đặc trưng từ ảnh.</li>
<li>Bước 2: Sử dụng Transfer Learning, đặt weights của 20 lớp Conv Layers đã được train ở bước 1 vào mạng detection (Ảnh 1). Do Weights của Conv Layers không phụ thuộc vào Input size nên tăng Input size lên 448x448 để mạng học được những đặc trưng chi tiết hơn của ảnh.</li>
<li>Bước 3: Lấy kết quả output của mạng detection, đem xử lý lại trước khi đặt vào hàm loss</li>
</ol>
<ul>
<li>Normalize (w,h) của bounding box để w,h trong đoạn [0,1]: (w = w/W , h = h/H | W,H: size của input)</li>
<li>Biến đổi toạ độ (x,y) thành toạ độ offset từ top-left của grid cell mà nó nằm trong để x, y nằm trong đoạn [0,1]. VD: x,y nằm chính giữa cell thì x = 0.5, y = 0.5</li>
<li>Confidence score của bounding box = IOU nên cũng nằm trong đoạn [0,1]</li>
<li>Ci là xác suất detect ra vật thể class i nên cũng nằm trong đoạn [0,1]</li>
</ul>
<blockquote>
<p>Tại sao phải có bước xử lý này? Đây là bước Scaling Features: đưa khoảng giá trị của các feature về cùng một scale trước khi vào hàm loss để giúp mô hình hội tụ nhanh và ổn định hơn khi training</p>
</blockquote>
<p>Bước 4: Xây dựng hàm Loss</p>
<div class="text-center my-3">
<figure class="figure">
  <img src="https://hungvm2.github.io/images/yolov1/loss_function.png" alt="Loss Function" class="figure-img">
  <figcaption class="figure-caption">Ảnh 2: Hàm loss</figcaption>
</figure>
</div>
<p>Hàm loss sử dụng là hàm Sum Squared Error. Tác giả giải thích lí do sử dụng hàm này vì nó dễ để tối ưu.</p>
<p>Tuy nhiên hàm này không đạt được độ chính xác AP (Average Precision) như mong đợi vì:</p>
<ul>
<li>Hàm này coi các giá trị về lỗi toạ độ (localization error) và lỗi phân loại (classification error) là tương đương với nhau (có thể thấy rõ trên công thức ở Ảnh 2)</li>
<li>Những grid cell không chứa object thì các giá trị Confidence scores sẽ bằng 0, việc này làm tăng sức mạnh của gradient (overpowering the gradient) ở những cell có chứa objects, khiến model bị mất ổn định. Để giải quyết, tác giả thêm các hệ số &ldquo;$λ_{coord} = 5$&rdquo; và &ldquo;$λ_{noobj} = 0.5$&rdquo; để tăng loss từ toạ độ bounding box và giảm loss từ Confidence score.</li>
</ul>
<p>Còn một vấn đề: box lớn thì sai số về kích thước (w, h) giữa predicted value và ground truth value cũng sẽ lớn hơn là box nhỏ. Để xử lý vấn đề này, tác giả sử dụng sai số giữa căn bậc hai của kích thước predict và ground truth thay vì giá trị w,h gốc. Ví dụ: Box To có predicted W = 9 và ground truth W = 8 =&gt; độ lệch = 1, Box Nhỏ có predicted W = 3 và ground truth W = 2 =&gt; độ lệch = 1. Rõ ràng Box nhỏ có sai số lớn hơn xét theo tỉ lệ, nhưng số tuyệt đối độ lệch thì như nhau</p>
<p>Khi training, mỗi grid cell cần predict B bounding boxes, tuy nhiên sẽ chỉ Bounding box có IOU lớn nhất so với ground truth box mới được chọn lựa để tính toán hàm loss (chọn làm &ldquo;predictor&rdquo;). Điều này sẽ giúp mỗi predicted Bounding box sẽ chỉ chuyên môn hoá vào việc detect object có kích thước, tỉ lệ nhất định, giúp tăng Recall của model</p>
<p>$\mathbb{1}_{i}^{obj}$ nhận giá trị 1 nếu object xuất hiện ở cell thứ $i$, 0 nếu ngược lại và $\mathbb{1}_{ij}^{obj}$ nhận giá trị 1 nếu bounding box thứ $j$ là "predictor", 0 nếu ngược lại</p>
<p>Bước 5: Training model detection</p>
<ul>
<li>Số Epochs: 135</li>
<li>Dataset: PASCAL VOC 2017 và 2012</li>
<li>Batch size: 64 (nếu có $m$ data points trong tập train thì mỗi epoch sẽ có $m/64$ iterations)</li>
<li>Momentum: 0.9 (Gradient Descent có sử dụng kỹ thuật momentum để hội tụ nhanh hơn)</li>
<li>Decay: 0.0005 (ý của tác giả ở đây có lẽ là Weight decay, một kỹ thuật regularization giúp giảm High Variance (Overfitting) (hơi giống L2 Regularization))</li>
<li>Learning rate (LR) schedule: tăng dần LR từ $10^{-3}$ tới $10^{-2}$ thay vì để LR cao từ đầu để tránh model bị phân kỳ (diverge) giai đoạn đầu, sau đó giữ nguyên LR $10^{-2}$ trong 75 epochs, giảm xuống $10^{-3}$ cho 30 epochs tiếp theo, giảm xuống $10^{-4}$ cho 30 epochs cuối.</li>
<li>Sử dụng dropout, rate = 0.5 sau layer FC đầu tiên, để giảm Overfitting</li>
<li>Data augmentation (làm giàu bộ dữ liệu): Random scaling (phóng to, thu nhỏ ngẫu nhiên), random translation (xê dịch vị trí pixel ngẫu nhiên) tới 20% kích thước ảnh. Ngẫu nhiên điều chỉnh độ phơi sáng (exposure) và bão hoà (saturation) của ảnh tới 1.5 lần trong không gian màu HSV.</li>
</ul>
<h5 id="phần-23-inference">Phần 2.3. Inference</h5>
<p>Giống như khi training, predict cũng chỉ cần một lần evaluate qua network.
Thiết kế kiểu grid giúp đa dạng hoá việc predict các bounding box
Thường tâm của object sẽ chỉ nằm trong 1 gird cell, tuy nhiên có những trường hợp như object lớn hoặc object nằm gần viền của nhiều cell nên dễ bị detect ra nhiều box cho cùng một object.
Thêm bước Non-max suppression (NMS) giúp triệt tiêu những box bị trùng khi detect cùng một object. Cải thiện thêm 2-3% mAP cho model.</p>
<p>Pipe line của prediction:</p>
<blockquote>
<p>Image (448,448,3) =&gt; Network Prediction =&gt; Output (7,7,30) =&gt; Tính lại class probabilities =&gt; Bỏ qua các box có low probabilities =&gt; Non-max suppression =&gt; Final prediction</p>
</blockquote>
<p>Xác suất nhận diện của các class trong ảnh sẽ được tính theo công thức sau:</p>
<div class="text-center my-3">
  <img src="https://hungvm2.github.io/images/yolov1/final_class_probs.png" alt="Class Probabilities" class="figure-img">
</div>
Take me to [<a href="#pookie" style="color:red;">1</a>]
<h4 id="phần-3-comparison-to-other-detection-systems">Phần 3. Comparison to Other Detection Systems</h4>
<p>Phần này tác giả so sánh YOLO với các mô hình detect object khác trước đó về FPS, mAP, tương đồng về kiến trúc một số thành phần, những cải tiến của YOLO so với các hệ thống này&hellip;
Các mô hình được so sánh gồm có: R-CNN, Fast R-CNN, Faster R-CNN ; DPM ; Deep MultiBox ; OverFeat ; MultiGrasp</p>
<h4 id="phần-4-experiments">Phần 4. Experiments</h4>
<p>Tác giả làm một số thí nghiệm:</p>
<ul>
<li>So sánh tốc độ/mAP của YOLO, biến thể Fast YOLO với các mô hình khác</li>
</ul>
<div class="text-center my-3">
<figure class="figure">
  <img src="https://hungvm2.github.io/images/yolov1/fps_map_comparison.png" alt="FPS/mAP Comparison" class="figure-img">
  <figcaption class="figure-caption">Ảnh 3: So sánh trên tập PASCAL VOC 2007</figcaption>
</figure>
</div>
+ Phân tích các lỗi của YOLO so với Fast R-CNN trên tập VOC 2007
<div class="text-center my-3">
<figure class="figure">
  <img src="https://hungvm2.github.io/images/yolov1/error_analysis.png" alt="Error Analysis" class="figure-img">
  <figcaption class="figure-caption">Ảnh 4: So sánh lỗi của YOLO và Fast R-CNN</figcaption>
</figure>
</div>
<ul>
<li>Kết hợp kết quả của YOLO với Fast R-CNN</li>
<li>Đo kết quả trên tập VOC 2012</li>
<li>Đo kết quả khi detect người trong các tác phẩm nghệ thuật (artwork)</li>
</ul>
<h4 id="phần-5-real-time-detection-in-the-wild">Phần 5. Real-Time Detection in the Wild</h4>
<p>Phần này tác giả cho model xử lý luồng từ camera để chứng minh tốc độ đạt real-time</p>
<h4 id="phần-6-conclusion">Phần 6. Conclusion</h4>
<p>Tác giả kết luận lại những ưu điểm của YOLO: kiến trúc đơn giản dễ xây dựng, một mô hình end-to-end, tốc độ xử lý nhanh, mức độ tổng quát hoá cao.</p>
<h3 id="ii-hiểu-paper">II. Hiểu Paper</h3>
<h3 id="iii-nguồn-tham-khảo">III. Nguồn tham khảo:</h3>
<p>[<span name="pookie" style="color:red;">1</span>]: bacdaf asdf asdf asdf asfasdf asfa</p>



                    </div>
                </div>
            </div>
        </div>
    </div>

    <section id="comments">
    <div class="py-3 content">
        <div class="container">
            <div class="row justify-content-center">
                <div class="col-sm-12 col-lg-8">
                    <div class="comments">
                        <script src="https://utteranc.es/client.js" repo=""
                            issue-term="pathname" label="comment" theme="github-light" crossorigin="anonymous" async>
                            </script>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>
    


    

    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js" defer></script>
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/stan.min.js" defer></script>
        
        <script>
            window.addEventListener('load', function() {
                hljs.initHighlighting();
            }, true);
        </script>
    

    

    
    
        
<script src="https://hungvm2.github.io/js/math-code.js"></script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    

</body>
</html>
